### 各种括号的用处

#### 变量原型 ${var}

```
a='this is a test'
echo a 				# a 
echo $a 			# this is a test
echo ${aAAA} 		# [没有输出，没有这个变量]
echo ${a}AA 		# this is a testAA
```



#### 命令替换 $(cmd)

```
echo $(ls)			# 相当于在终端中输入ls命令,如果括号中有多个命令需要使用分号分割
echo `ls`			# 与$(ls) 功能一样

echo $(ls;cat task.txt;)	# 需要注意的是，多个命令才这样用，单个命令就是没有分号的情况了，最后一个分号可有可无
echo $(ls;cat task.txt)	# 最后一个命令可以没有分号
```



#### 一串的命令执行() 和 {}

```
 (var=4000;echo $var)  	# 最后一个命令可以不使用';'
 { var=3333;echo $var;}	# 最后一个命令必须使用';'，'{'与第一个指令必须有一个空格
# 注意区别  左括号与第一个命令是否有空格， 最后一条命令是否有';'  需要注意'{}'要求比较的
```

##### 重定向

```
{ var1=test1;var2=test2;echo $var1>tmp.txt;echo $var2;}		# 将var1的输出重定向写入到tmp.txt中, var2依然输出到标准输出中
{ var1=test1;var2=test2;echo $var1;echo $var2;}>tmp.txt  	# 将所有执行的命令都写入到tmp.txt中
```



#### 几种替换结构 

```
newVar=
echo ${newVar:-'newVar为空输出我，否则输出它自己'}		
# ${var:-string} 如果var为空输出string，否则输入$var  与高级语言三目运算符一致

echo ${newVar:='newVar为空将我赋值给newVar并输出newVar'}		
# ${var:=string} 如果var为空,则将string赋值给var，然后再输出$var。 不为空直接输出var
# 这个用的比较多，判断值存在不，不存在就赋个值


# newVar=				# 这样下面脚本会抛出错误 none str, 如果改为有值就会直接执行
echo ${newVar:?'newVar为空时作为错误输出'}		
# ${var:?string} 若变量为空，则将string输出到标准错误中，并从脚本中退出，可以利用这个特性检查是否设置了变量的值。
echo '脚本结束'

echo ${newVar:+'newVar不为空时输出'}		
# $(var:+string) 与上面规则正好相反，当var不为空输出string，为空时不替换

# 注意，这里使用的string 可以是通过命令或者变量得到的数值， 不然岂不是很无用

```



#### POSIX标准的扩展计算:$((exp))

```
# 这种计算是符合C语言的运算符，也就是说只要符合C的运算符都可用在$((expr)),甚至是三目运算符。 不过只能用于整形数，表达式exp为真则为1，否则为0
echo $((3+3))
echo $((2<4))
echo $((var=2+3))
echo $var
echo $((var++))   		# 能想到的C语言运算都可以试下
echo $var
```



#### 模式匹配替换结构

```
# 小理解  看键盘 # 在左边  %在右边     从左匹配取右侧的值，成功后移除左侧匹配到的内容；从右匹配取左侧的值，移除右侧匹配的内容； 需要注意的是，*位置 从右在右，从左在左
# ## %% 为贪婪匹配		# % 为非贪婪匹配

# 此外注意，这里使用的匹配本非完整的正则表达式，而是使用普通匹配的规则：*代表所有

var=aabbbcccccdddeefff
echo ${var%b*}				# 【最短匹配】从右侧开始比较，如果最右侧是b则输出b左侧所有字符，否则输出所有内容   
#aabb 			# 最短匹配，从右侧可以有多个字符，能匹配到的最左侧是一个b,可以匹配到一个b
echo ${var%%b*}				# 【最长匹配】从右侧匹配，如果不使用正则表达式 最短匹配与最长匹配没有差别
# aa   			# 最长匹配  从右侧可以有多个字符，能匹配到的最左侧是一个b，可以匹配到bb

echo ${var#*e}				# [最短匹配】从左侧匹配，取右侧的值
#efff
echo ${var##*e}
#fff

#下面无法匹配
echo ${var##e*}				# 因为取匹配到的字符右侧的值，使用通配符*导致找不到匹配的值
#aabbbcccccdddeefff
echo ${var%*e}
#aabbbcccccdddeefff			# 同理，取匹配到的左侧的值
```



小栗子：搜索文件夹中使用了`grep`串的文件

```
#!/bin/bash
grep -r -i 'grep' $1 | while read line
do
	echo '完整的串：'$line
	echo '整理后的串：'${line##*:}
done
```



#### 双括号的其他用法

##### for循环

```
for (( i = 0; i < 10; i++ )); do
	echo $i
done
```

##### 数学表达式

```
# (()) 与 let一样
let a=10
((a=10))
```

##### 字符串中的计算结果

```
echo "1+2=$((1+3))"
# 1+2=4
```



#### 中括号

##### 单个中括号

- `bash`内部命令，`[`和`test`是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。`if/test`结构的左括号是调用test的命令表示，右中括号是关闭条件判断的。  用的还不多，后续理思路。


- `test`和`[]`中可用的比较运算符只有`== 和 !=`两者都是用于字符串比较，不可用于整数比较，__整数比较只能使用`-eq, -gt`这种形式__ 无论字符串比较还是整数比较都不支持大于号／小于号。如果实在想用。对于字符串可以使用转义形式。 
- 用于数组中

示例：

```
a=abc b=aef
if [ $a \> $b ]; then
	echo "a > b"
else
	echo 'a < b'
fi
```



##### 如果是用来比较写法有几种

```
# 数字
if [[ $1 > $((2**10)) ]]; then				// 无法正确比较
	echo $1
else 
	echo "not bigger than  $((2**10))"
fi
exit 0

# 可以调整为：
if (($1 > $((2**10)))) ; then
# or
if [[ $1 -gt $((2**10)) ]]; then
# or
if [ $1 -gt $((2**10)) ]; then

# 总结： 数字：> < = 需要使用((expr)) 进行判断不使用[] or [[]]   ，在[] or [[]] 最好使用-eq -ne -gt 等这种表示方式； 


# 字符串
if [ "$a" = $b ]    
# or
if [[ "$a" == "$b" ]] # 与=等价

# == 在[[]] 表示相等  在[] 表示为其他意思，暂时不考虑
# < > 用于字符串的时 [[]] 可以直接使用 [] 需要转义
if [[ "$a" < "$b" ]]
if [ "$a" \< "$b" ]

# -z 字符串长度为0
# -n 字符串为nonenull   即不为空
```






##### 两个中括号

- `[[` 是bash程序语言的关键字。并不是一个命令，`[[]]` 结构比`[]`更加通用。在`[[]]`中的所有的自符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。
- 模式匹配，需要掌握下
- 使用`[[]]` 条件判断，能防止脚本中的许多逻辑错误，比如`&&` `||` `<` `>` 操作符能够正常存在于`[[]]`条件判断结构中，但是在`[]` 中就容易出错了。
- bash 把双括号中的表达式看作一个单独的元素，并返回一个退出状态码。

```
  a=4 b=7
  if [[ $a != 3 && $b != 4 ]]; then   #如果不用这种写法的话就要用下面两种替换，麻烦不少
  	echo '符合条件'
  fi

  if [ $a -ne 3 ] && [ $b != 4 ]; then
  	echo '符合条件'
  fi

  # 或
  if [ $a -ne 3 -a $b != 4 ]; then
  	echo '符合条件'
  fi
```

  

#### test命令 【待补充】

#### 字符串截取 【待补充】

分号的功能； 分命令

```
arr=(1 2 3 40 5)
for i in ${arr[@]}; do   // 分号使用来分命令的，如果do在下一行就不需要有分号了
	echo $i 
done

```



<a href="http://www.jb51.net/article/60326.htm" target="_blank">参考资料</a>