### alias命令解析

在linux系统中经常碰到非常长的命令，每次打起来很麻烦这时就可以使用别名来进行设置快捷操作方式。意思就是取一个别名。

格式如下

```
// 创建别名
alias 新的命令='原命令 -选项/参数'

// 移除别名
unalias 别名
```

栗子

```
# 本来是没有la这个命令的
alias la='ls -a' #可以使用la来进行操作了
```

使用这种方式，直接声明会在重启之后便失效。如果不想这么快失效可以设置到`~/.bashrc` 文件中。

```
 alias la='ls -a' >> ~/.bashrc 			# 注意是添加到源文件尾部，不要错写成 > 会覆盖掉
```

如果不想使用别名，可以通过`\` 来忽略

```
\la
# -bash: la: command not found
```

移除别名

```
unalias la
```

__注意__ 

使用别名，内部不可以有通道`|`

```
 ls -a | while read line;do echo $line; done		# 可以打印
 
 alias la=" ls -a | while read line;do echo $line; done" 	# 使用la不能起到作用
```



### 后台运行线程

一般来说在终端上运行的进程在终端关闭或网络断开就会导致任务失败。这是因为当用户注销或网络断开时，终端会收到HUP(hangup)信号从而关闭其所有子线程。因此解决方式有两种：

* 让进程忽略HUP信号
* 让进程运行在新的会话里从而不属于此终端的子进程。

只需要记住在命令后面添加`&`就可以放到后台执行

#### nohub

nohub的用途就是让提交的命令忽略hangup信号

栗子：

```
# 只需要在处理的命令前加上nohup即可，标准输出和标准错误输出会到nohup文件中。可以通过>filename 2>errorfile 重定向。
# 一般可以在结尾上加上 & 来将命令防盗后台运行
nohup ping www.baidu.com.com &
```



#### &

将一个或多个命令包含在"()"中就能让这些命令在子`shel`l中运行，从而扩展出许多有意思的功能。

当我们把`&`放到`()`内后，就会发现所提交的作业并不再作业列表中，也就是说，是无法通过`jobs`来查看的。

栗子

```
ping www.baidu.com &		# 防盗后台线程中执行
```

